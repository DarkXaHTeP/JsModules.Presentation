<!DOCTYPE html><html lang="en"><head><title>JS Modules</title><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="stylesheet" href="styles/reveal.css"><link rel="stylesheet" href="styles/theme/beige.css"><link rel="stylesheet" href="lib/css/zenburn.css"><link rel="stylesheet" href="styles/styles.css"></head><body><div class="reveal"><div class="slides"><section><h1>Modules in JavaScript</h1><h4>from dark ages to ES2015</h4><img src="images/modules_illustration.jpg"></section><section><h2>Let's start with simple things</h2><img src="images/java-javascript.jpg"></section><section><h2>Agenda</h2><ul><li>Global scope</li><li>Module pattern</li><li>Revealing module pattern</li><li>CommonJS modules</li><li>Browserify</li><li>AMD (RequireJS)</li><li>ES2015 (ES6, ES.Next, Harmony) modules</li><li>Current state and support</li><li>Questions?</li><li>Demo overview</li></ul></section><section><section><h2>Global scope</h2><p>JavaScript has two scopes: global and local. A variable that is declared outside a function definition is a global variable, and its value is accessible and modifiable throughout your program. A variable that is declared inside a function definition is local.</p></section><section><pre><code class="js">var a = 1; //global variable, becomes a property of window object also

function () {
 var b = 2; // local variable
 c = 3; //implicit global variable, will cause Error in strict mode
}

console.log(a); //1
console.log(window.a); //1
console.log(b); //undefined
console.log(window.b); //undefined
console.log(c); //3
console.log(window.c); //3</code></pre></section><section><p>There are many variables initially defined in global scope</p><img src="images/Window_object.png"><p>You can accidently overwrite something</p><p>Global variable will not be eligible for collection until the global namespace loses scope.</p></section><section><p>Always beware that someone will declare the variable with the same name as yours and the app will work incorrectly</p><img src="images/unexpected.gif"></section></section><section><section><h2>How can we deal with it?</h2><img src="images/sceptic_woman.jpg"></section><section><h2>Panic</h2><img src="images/yanukovich.gif"></section><section><h2>Find the creator of bad code</h2><img src="images/name_conflict.jpg"></section></section><section><section><h2>Self-executing anonymous function</h2><p>Creates local scope and executes it immediately</p><pre><code class="js">//Global scope is here

(function(){
 //This is the local scope of the function, no globals are created
 var hello = 'Hello World!'
 console.log(hello);

//Function is immediatly executed after creation
})();</code></pre></section><section><h2>Module pattern</h2><p>The most commonly used design pattern and widely accepted in a number of large projects such as jQuery, Dojo, ExtJS and YUI.</p><h4>Pros/Cons</h4><p><ul><li class="greened">Supports private data</li><li class="greened">Less clutter in the global namespace</li><li class="reded">Private methods and functions lose extendability since they are unaccessible.</li></ul></p></section><section><pre><code class="js">(function( window, undefined ) {
 function MyModule() {
   // `this` refers to the instance of `MyModule` when created
   this.myMethod = function () {
     alert( 'my method' );
   };
 }

 // expose access to the constructor
 window.MyModule = MyModule;
})( window );

// example usage
var myModule = new MyModule();
myModule.myMethod(); // alerts "my method"</code></pre></section><section><h2>Revealing module pattern</h2><p>The only difference from the module pattern is that this pattern was engineered as a way to ensure that all methods and variables are kept private until they are explicitly exposed.</p><h4>Pros/Cons</h4><p><ul><li class="greened">Supports private data</li><li class="greened">Less clutter in the global namespace</li><li class="greened">The syntax of our scripts are even more consistent</li><li class="greened">Explicitly defined public methods and variables which lead to increased readability</li><li class="reded">Private methods and functions lose extendability since they are unaccessible.</li></ul></p></section><section><pre><code class="js">var myModule = (function( window, undefined ) {
 function myMethod() {
   alert( 'my method' );
 }

 // explicitly return public methods when this object is instantiated
 return {
   someMethod : myMethod
 };
} )( window );

//  example usage
MyModule.myMethod(); // undefined
MyModule.someMethod(); // alerts "my method"</code></pre></section></section><section><h2>Standardization of the modules</h2><p>EcmaScript 3 was released in December 1999 and EcmaScript 5 in December 2009. None of them contained the out of the box implementation of the modules. Module pattern interpretation differs from project to project, modules are hard to reuse.</p><img src="images/gold_standard.jpg"></section><section><section><h2>CommonJS Modules specification</h2><img src="images/CommonJS.png"><p>The CommonJS group defined a module format to solve JavaScript scope issues by making sure each module is executed in its own namespace. This is achieved by forcing modules to explicitly export those variables it wants to expose to the “universe”, and also by defining those other modules required to properly work.</p></section><section><h2>CommonJS Syntax</h2><p>To achieve this CommonJS give you two tools:<ol><li>the "require()" function, which allows to import a given module into the current scope.</li><li>the "module" object, which allows to export something from the current scope.</li></ol></p></section><section><img src="images/show_code.jpg"></section><section><h4>math.js</h4><pre><code class="js">exports.add = function() {
   var sum = 0, i = 0, args = arguments, l = args.length;
   while (i < l) {
       sum += args[i++];
   }
   return sum;
};</code></pre><h4>increment.js</h4><pre><code class="js">var add = require('math').add;
module.exports = function(val) {
   return add(val, 1);
};</code></pre><h4>program.js</h4><pre><code class="js">var inc = require('increment');
var a = 1;
inc(a); // 2</code></pre></section><section><h2>Implementations of the spec</h2><p>CommonJS modules' 'require()' function call will block the execution until the required module will be loaded into the memory and initialized. This approach cannot be used in the browsers, that's why CommonJS modules were applied to the node.js platform and become a standard there for a long time.</p><img src="images/nodejs.png"></section><section><h2>Pros/Cons</h2><p><ul><li class="greened">Simple syntax - easy to use</li><li class="greened">Execution in own context. Only explicit variables in the global namespace</li><li class="greened">Modules format consistent and behavior is predictable</li><li class="greened">NPM registry contains thousands of modules ready to use</li><li class="greened">Dependencies can be stubbed during the testing.</li><li class="reded">Synchronous execution</li><li class="reded">Not supported in browsers</li><li class="reded">Implemented in Node.JS only</li></ul></p></section></section><section><section><h2>Any thoughts about browsers?</h2><img src="images/browsers.jpg"></section><section><q>If the mountain will not come to Mohammed, Mohammed must go to the mountain</q><img src="images/mountain.jpg"></section></section><section><section><img src="images/browserify.png"><p>Browsers don't have the "require()" method defined, but Node.js does. With Browserify you can write code that uses require in the same way that you would use it in Node by bundling up all of your dependencies into single JavaScript file.</p></section><section><h2>How to use</h2><p>Install Browserify from NPM</p><pre><code class="bash">npm install -g browserify</code></pre><p>Compile CommonJS module with all it's dependencies into bundle</p><pre><code class="bash">browserify main.js --outfile=bundle.js</code></pre></section><section><h2>Pros/Cons</h2><p><ul><li class="greened">All benefits of CommonJS in browser (and even more with transforms)</li><li class="greened">Ability to reuse server code (e.g. models, helpers)</li><li class="reded">Knowledge of the Node.JS platform is recommended</li><li class="reded">Build step is required</li><li class="reded">Generated code is hard to read (without source maps)</li></ul></p></section></section><section><p>Not all developers were ready to build their frontend. Not all of the projects have Node.JS as a backend.</p><img src="images/alternative.jpg"></section><section><section><h2>Here comes AMD</h2><img src="images/amd-chip.jpg"></section><section><h2>Asynchronous Module Definition (AMD)</h2><p>The API specifies a mechanism for defining modules such that the module and its dependencies can be asynchronously loaded. This is particularly well suited for the browser environment.</p></section><section><h4>math.js</h4><pre><code class="js">define([], function() {
 return {
   add: function() {
     var sum = 0, i = 0, args = arguments, l = args.length;
     while (i < l) {
       sum += args[i++];
     }
     return sum;
   };
});</code></pre><h4>increment.js</h4><pre><code class="js">define(['math'], function(math) {
 return function(val) {
   return math.add(val, 1);
 };
});</code></pre><h4>program.js</h4><pre><code class="js">require(['increment'], function(increment) {
 var a = 1;
 inc(a); // 2
});</code></pre></section><section><h2>Relations with CommonJS group</h2><p>First version of AMD API started on the CommonJS wiki as a transport format, as Modules Transport/C, but it changed over time to also include a module definition API.</p><p>Consensus was not reached. The API was transferred over to its own wiki and discussion group.</p></section><section><h2>Existing implementations:</h2><p><ul><li>Dojo Toolkit</li><li>ScriptManJS</li><li>RequireJS</li></ul></p><img src="images/requirejs-logo.png"></section><section><h2>Pros/Cons</h2><p><ul><li class="greened">Asynchronous loading</li><li class="greened">Designed for browsers, but can be used on server as well</li><li class="greened">Execution in function local scope. Only explicit variables in the global namespace</li><li class="greened">Modules format consistent and behavior is predictable</li><li class="greened">Dependencies are loaded only if required</li><li class="reded">More boilerplate code in comparison to CommonJS</li><li class="reded">Mocking of dependencies during testing is not easy</li></ul></p></section></section><section><h2>UMD (Universal Module Definition)</h2><p>The UMD pattern typically attempts to offer compatibility with the most popular script loaders of the day (e.g RequireJS amongst others). In many cases it uses AMD as a base, with special-casing added to handle CommonJS compatibility.</p><p>It is possible to create UMD modules using Browserify:</p><pre><code class="bash">browserify module.js --outfile=myModule.js --standalone</code></pre></section><section><blockquote>Waiting for out of the box module support in JavaScript</blockquote><img src="images/waiting-skeleton.jpg"></section><section><section><h2>EcmaScript 2015 modules</h2><p>The ES2015 (former ES6, ES.Next, Harmony) brought the native modules support to the JavaScript among the many other innovations.</p></section><section><img src="images/harold.jpg"></section><section><h4>math.js</h4><pre><code class="js">export function add() {
   var sum = 0, i = 0, args = arguments, l = args.length;
   while (i < l) {
       sum += args[i++];
   }
   return sum;
};</code></pre><h4>increment.js</h4><pre><code class="js">import { add } from 'math';
export default function(val) {
   return add(val, 1);
};</code></pre><h4>program.js</h4><pre><code class="js">import inc from 'increment';
var a = 1;
inc(a); // 2</code></pre></section><section><h2>Design goals</h2><p><ul><li>Exporting of single item is favored over multiple</li><li>Static module structure</li><li>Support for both synchronous and asynchronous loading</li><li>Support for cyclic dependencies between modules</li></ul></p><img src="images/design.jpg"></section><section><h2>Pros/Cons</h2><p><ul><li class="greened">Very compact syntax</li><li class="greened">Static module structure (helps with optimizations, static checking and more)</li><li class="greened">Hopefully will end the fragmentation between the CommonJS and AMD (no more UMD)</li><li class="greened">New browser APIs become modules instead of global variables or properties of navigator</li><li class="greened">No more objects-as-namespaces (such as Math and JSON) for functions in ECMAScript 5</li><li class="reded">No support in browsers and Node.JS for now</li><li class="reded">Transpiling to CommonJS/AMD is required. A build step should be introduced</li></ul></p></section></section><section><h2>Current state</h2><p>So where the modules will work?</p><table><thead><tr><th>Modules</th><th>In browser</th><th>In Node.JS</th><th>In browser (build)</th><th>In Node (build)</th></tr></thead><tbody><tr><td>CommonJS</td><td>-</td><td>+</td><td>+</td><td></td></tr><tr><td>AMD</td><td>+</td><td>-</td><td>+</td><td>+</td></tr><tr><td>UMD</td><td>+</td><td>+</td><td>+</td><td></td></tr><tr><td>ES2015</td><td>-</td><td>-</td><td>+</td><td>+</td></tr></tbody></table></section><section><h4>My way of dealing with modules</h4><p><ul><li>Use ES2015 syntax for own modules</li><li>Use babel transform to transpile modules to CommonJS syntax</li><li>Use Browserify to wrap third-party CommonJS dependencies and get bundle</li></ul></p><pre><code class="bash">browserify src/index.js -t babelify | uglifyjs > public/bundle.js</code></pre><img src="images/deal-with-it.gif"></section><section><h2>What to read</h2><p><ul><li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank">Book: Learning JavaScript Design Patterns</a></li><li><a href="https://nodejs.org/docs/latest/api/modules.html" target="_blank">Node.JS Modules</a></li><li><a href="http://requirejs.org/docs/api.html" target="_blank">AMD API overview using RequireJS</a></li><li><a href="http://browserify.org/" target="_blank">Browserify documentation</a></li><li><a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank">ES6 Modules in Depth</a></li><li><a href="https://auth0.com/blog/2016/03/15/javascript-module-systems-showdown/" target="_blank">JavaScript Module Systems Showdown: CommonJS vs AMD vs ES2015</a></li></ul></p></section><section><h2>Questions?</h2><img src="images/questions.gif"></section><section><h2>Demo overview</h2><a href="https://github.com/DarkXaHTeP/JsModules.Demo">open on GitHub</a></section></div></div><script src="lib/js/head.min.js"></script><script src="scripts/reveal.js"></script><script src="scripts/main.js"></script></body></html>